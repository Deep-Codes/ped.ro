---
title: 'Code blocks, but better'
publishedAt: '2021-05-02'
---

I've been exploring ways to improve the code blocks on the Stitches and Radix documentation sites.

For an enhanced user experience, I wanted to be able to:

- Syntax highlight
- Apply multiple themes
- Highlight specific lines
- Highlight specific words
- Interact with the content
- Make specific words link to other pages
- Show line numbers
- Make it collapsible/expandable
- Render a preview

In terms of developer experience, the documentation sites are built using [Next.js]() and the content is authored with [MDX]().

In this post, I'll show you how I made a custom code block with the features above.

Ready? Let's get it.

---

## Demo

I'll be using the code block of my own website as the demo, it looks like this:

### Syntax highlight

A minimal demo, showing the syntax highlighting:

```jsx
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Apply multiple themes

Render the code block in different styles. Like this orange theme:

```jsx theme=orange
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

Or this pink theme:

```jsx theme=pink
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

Or turquoise:

```jsx theme=turq
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Highlight specific lines

Drive attention to specific parts in the code:

```jsx line=1,4
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Highlight specific words

Drive attention to specific words in the code:

```jsx
import React from 'react';

export function Counter({ __initialCount__ = 0 }) {
  const [count, setCount] = React.useState(__initialCount__);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Interact with the content

Create connections between the content and the code block.

Try it yourself, <H id="demo1" index="1,2">hover me</H> and watch the code block:

```jsx id=demo1
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, __setCount__] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => __setCount__((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Make specific words link to other pages

Click a highlighted word to navigate to a different page:

<RegisterLink id="demo2" index="1" href="https://reactjs.org/" />

```jsx id=demo2
import React from '__react__';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Show line numbers

Choose whether to display line numbers or not:

```jsx showLineNumbers
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Render a preview

Render an interactive preview of what your code block is showing. Click the button!

{

<Preview>
  <DemoCounter initialCount={32} />
</Preview>
}

```jsx
<Counter initialCount={32} />
```

### Make it collapsible/expandable

Option to have the code block collpased:

{

<Preview>
  <DemoCounter initialCount={99} color="orange" />
</Preview>
}

```jsx collapsible
<DemoCounter initialCount={99} />
```

---

## Implementation

### Context

I've built this to work on Next.js projects. For `.mdx` support, I've used it with [mdx-bundler]() and [next-mdx-remote]().

However, any framework/library that supports rehype plugins should work fine.

### Dependencies

Next, these are the dependencies I rely on:

```bash
# for code block features
yarn add unist-util-visit
yarn add refractor
yarn add hast-util-to-string
yarn add hast-util-to-html
yarn add unified
yarn add rehype-parse
yarn add parse-numeric-range

# for styling:
yarn add @stitches/react

# for collapsible logic:
yarn add @radix-ui/react-collapsible
```

## Syntax highlight

The most basic requirement is to be able to do syntax highlighting.

For this, I created a rehype plugin using [refractor](https://github.com/wooorm/refractor) by [wooorm]().

```js
// rehype-highlight-code.js
const visit = require('unist-util-visit');
const nodeToString = require('hast-util-to-string');
const refractor = require('refractor');

module.exports = (options = {}) => {
  return (tree) => {
    visit(tree, 'element', visitor);
  };

  function visitor(node, index, parentNode) {
    if (parentNode.tagName === 'pre' || node.tagName === 'code') {
      // syntax highlight
      const lang = node.properties.className ? node.properties.className[0].split('-')[1] : 'md';
      let result = refractor.highlight(nodeToString(node), lang);

      node.children = result;
    }
  }
};
```

> Plugin inspired by [mdx-prism](https://github.com/j0lv3r4/mdx-prism).

The rehype plugin wraps the content of my code block in various `span` elements with different classes, such as `function`, `operator`, `keyword`, etc.

For example, this code block:

```html
<h1>Hello world</h1>
```

renders this html:

{<pre>
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;Hello world&lt;span
class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;

</pre>}

### Adding the styles

I was then able to target these classes and style them. To do this in a maintanable way, I used [Stitches]().

With Stitches I am able to create a theme, and then use its tokens to later style the syntax highlight. But if you don't want to create your own theme, you can use [Prism themes](https://github.com/PrismJS/prism-themes).

```jsx
// stitches.config.ts
import { createCss } from '@stitches/react';

export const { styled } = createCss({
  theme: {
    fonts: {
      mono: 'Fira Mono, monospace',
    },
    fontSizes: {
      1: '12px',
      2: '14px',
    },
    colors: {
      black: 'rgba(19, 19, 21, 1)',
      white: 'rgba(255, 255, 255, 1)',
      gray: 'rgba(128, 128, 128, 1)',
      blue: 'rgba(3, 136, 252, 1)',
      red: 'rgba(249, 16, 74, 1)',
      yellow: 'rgba(255, 221, 0, 1)',
      pink: 'rgba(232, 141, 163, 1)',
      turq: 'rgba(0, 245, 196, 1)',
      orange: 'rgba(255, 135, 31, 1)',
    },
    space: {
      1: '4px',
      2: '8px',
      3: '16px',
    },
    radii: {
      1: '2px',
      2: '4px',
    },
  },
});
```

Now that Stitches is set up, I could import the `styled` function and use it to style the `pre` element.

```jsx
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  $$background: 'hsla(206 12% 89.5% / 5%)',
  $$text: '$colors$white',
  $$syntax1: '$colors$orange',
  $$syntax2: '$colors$turq',
  $$syntax3: '$colors$pink',
  $$syntax4: '$colors$pink',
  $$comment: '$colors$gray',
  $$removed: '$colors$red',
  $$added: '$colors$turq',

  boxSizing: 'border-box',
  padding: '$3',
  overflow: 'auto',
  fontFamily: '$mono',
  fontSize: '$2',
  lineHeight: '$3',
  whiteSpace: 'pre',
  backgroundColor: '$$background',
  color: '$$text',

  '& > code': { display: 'block' },

  '.token.parameter': {
    color: '$$text',
  },

  '.token.tag, .token.class-name, .token.selector, .token.selector .class, .token.function': {
    color: '$$syntax1',
  },

  '.token.attr-value, .token.class, .token.string, .token.number, .token.unit, .token.color': {
    color: '$$syntax2',
  },

  '.token.attr-name, .token.keyword, .token.rule, .token.operator, .token.pseudo-class, .token.important': {
    color: '$$syntax3',
  },

  '.token.punctuation, .token.module, .token.property': {
    color: '$$syntax4',
  },

  '.token.comment': {
    color: '$$comment',
  },

  '.token.atapply .token:not(.rule):not(.important)': {
    color: 'inherit',
  },

  '.language-shell .token:not(.comment)': {
    color: 'inherit',
  },

  '.language-css .token.function': {
    color: 'inherit',
  },

  '.token.deleted:not(.prefix), .token.inserted:not(.prefix)': {
    display: 'block',
    px: '$4',
    mx: '-$4',
  },

  '.token.deleted:not(.prefix)': {
    color: '$$removed',
  },

  '.token.inserted:not(.prefix)': {
    color: '$$added',
  },

  '.token.deleted.prefix, .token.inserted.prefix': {
    userSelect: 'none',
  },
});
```

### Breaking it down

Let me go through it step-by-step.

#### 1. Creating a component

I'm importing the `styled` function from `stitches.config.ts`. That's where we did the set up, to provide Stitches with our theme. Then I use the `styled` function to create a Stitches component.

```jsx
import { styled } from './stitches.config';

export const Pre = styled('pre', {...});
```

#### 2. Creating locally scoped tokens

I took advantage of Stitches' [locally-scoped tokens]() to define some variables that I'll then use to highlight the syntax.

This came in super handy when creating additional themes. Keep reading...

```jsx line=4-12
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  $$background: 'hsla(206 12% 89.5% / 5%)',
  $$text: '$colors$white',
  $$syntax1: '$colors$orange',
  $$syntax2: '$colors$turq',
  $$syntax3: '$colors$pink',
  $$syntax4: '$colors$pink',
  $$comment: '$colors$gray',
  $$removed: '$colors$red',
  $$added: '$colors$turq',

  // styles
});
```

#### 3. Adding base styles

Then I added the base styles for the `pre` and `code` elements.

```jsx line=6-16
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  // locally-scoped tokens

  boxSizing: 'border-box',
  padding: '$3',
  overflow: 'auto',
  fontFamily: '$mono',
  fontSize: '$2',
  lineHeight: '$3',
  whiteSpace: 'pre',
  backgroundColor: '$$background',
  color: '$$text',

  '& > code': { display: 'block' },

  // styles
});
```

#### 4. Adding syntax styles

I could target the classes generated by the rehype plugin and add syntax highlighting. With Stitches, I was able to reference the locally-scoped tokens, by using `$$` (two dollar signs).

```jsx line=6-58
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  // locally-scoped tokens and base styles

  '.token.parameter': {
    color: '$$text',
  },

  '.token.tag, .token.class-name, .token.selector, .token.selector .class, .token.function': {
    color: '$$syntax1',
  },

  '.token.attr-value, .token.class, .token.string, .token.number, .token.unit, .token.color': {
    color: '$$syntax2',
  },

  '.token.attr-name, .token.keyword, .token.rule, .token.operator, .token.pseudo-class, .token.important': {
    color: '$$syntax3',
  },

  '.token.punctuation, .token.module, .token.property': {
    color: '$$syntax4',
  },

  '.token.comment': {
    color: '$$comment',
  },

  '.token.atapply .token:not(.rule):not(.important)': {
    color: 'inherit',
  },

  '.language-shell .token:not(.comment)': {
    color: 'inherit',
  },

  '.language-css .token.function': {
    color: 'inherit',
  },

  '.token.deleted:not(.prefix), .token.inserted:not(.prefix)': {
    display: 'block',
    px: '$4',
    mx: '-$4',
  },

  '.token.deleted:not(.prefix)': {
    color: '$$removed',
  },

  '.token.inserted:not(.prefix)': {
    color: '$$added',
  },

  '.token.deleted.prefix, .token.inserted.prefix': {
    userSelect: 'none',
  },
});
```

### Applying multiple themes

I relied on the Stitches Variant API to create multiple variations of the `Pre` component.

Creating multiple themes was as simple as overriding the previously created locally-scoped tokens. Love it!

```jsx line=6-30
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  // locally-scoped tokens and base styles

  variants: {
    theme: {
      orange: {
        $$background: 'rgb(255 135 31 / 10%)',
        $$syntax1: '$colors$pink',
        $$syntax2: '$colors$turq',
        $$syntax3: '$colors$orange',
        $$syntax4: '$colors$orange',
      },
      pink: {
        $$background: 'hsl(345deg 66% 73% / 20%)',
        $$syntax1: '$colors$orange',
        $$syntax2: '$colors$turq',
        $$syntax3: '$colors$pink',
        $$syntax4: '$colors$pink',
      },
      turq: {
        $$background: 'rgba(0, 245, 196, 0.15)',
        $$syntax1: '$colors$orange',
        $$syntax2: '$colors$pink',
        $$syntax3: '$colors$turq',
        $$syntax4: '$colors$turq',
      },
    },
  },
});
```
