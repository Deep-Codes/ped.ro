---
title: 'Code blocks, but better'
publishedAt: '2021-05-02'
---

I've been exploring ways to improve the code blocks on the Stitches and Radix documentation sites.

For an enhanced user experience, I wanted to be able to:

- Syntax highlight
- Apply multiple themes
- Highlight specific lines
- Highlight specific words
- Interact with the content
- Make specific words link to other pages
- Show line numbers
- Make it collapsible/expandable
- Render a preview

In terms of developer experience, the documentation sites are built using [Next.js]() and the content is authored with [MDX]().

In this post, I'll show you how I made a custom code block with the features above.

Ready? Let's get it.

---

## Demo

I'll be using the code block of my own website as the demo, it looks like this:

### Syntax highlight

A minimal demo, showing the syntax highlighting:

```jsx
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Apply multiple themes

Render the code block in different styles. Like this orange theme:

```jsx theme=orange
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

Or this pink theme:

```jsx theme=pink
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

Or turquoise:

```jsx theme=turq
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Highlight specific lines

Drive attention to specific parts in the code:

```jsx line=1,4
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Highlight specific words

Drive attention to specific words in the code:

```jsx
import React from 'react';

export function Counter({ __initialCount__ = 0 }) {
  const [count, setCount] = React.useState(__initialCount__);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Interact with the content

Create connections between the content and the code block.

Try it yourself, <H id="demo1" index="1,2">hover me</H> and watch the code block:

```jsx id=demo1
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, __setCount__] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => __setCount__((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Make specific words link to other pages

Click a highlighted word to navigate to a different page:

<RegisterLink id="demo2" index="1" href="https://reactjs.org/" />

```jsx id=demo2
import React from '__react__';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Show line numbers

Choose whether to display line numbers or not:

```jsx showLineNumbers
import React from 'react';

export function Counter({ initialCount = 0 }) {
  const [count, setCount] = React.useState(initialCount);
  return (
    <button type="button" onClick={() => setCount((prevCount) => prevCount + 1)}>
      {count}
    </button>
  );
}
```

### Render a preview

Render an interactive preview of what your code block is showing. Click the button!

{

<Preview>
  <DemoCounter initialCount={32} />
</Preview>
}

```jsx
<Counter initialCount={32} />
```

### Make it collapsible/expandable

Option to have the code block collpased:

{

<Preview>
  <DemoCounter initialCount={99} color="orange" />
</Preview>
}

```jsx collapsible
<DemoCounter initialCount={99} />
```

---

## Implementation

### Context

I've built this to work on Next.js projects. For `.mdx` support, I've used it with [mdx-bundler]() and [next-mdx-remote]().

However, any framework/library that supports rehype plugins should work fine.

### Dependencies

Next, these are the dependencies I rely on:

```bash
# for code block features
yarn add unist-util-visit
yarn add refractor
yarn add hast-util-to-string
yarn add hast-util-to-html
yarn add unified
yarn add rehype-parse
yarn add parse-numeric-range

# for styling:
yarn add @stitches/react

# for collapsible logic:
yarn add @radix-ui/react-collapsible
```

## Syntax highlight

The most basic requirement is to be able to do syntax highlighting.

For this, I created a rehype plugin using [refractor](https://github.com/wooorm/refractor) by [wooorm]().

```js
// rehype-highlight-code.js
const visit = require('unist-util-visit');
const nodeToString = require('hast-util-to-string');
const refractor = require('refractor');

module.exports = (options = {}) => {
  return (tree) => {
    visit(tree, 'element', visitor);
  };

  function visitor(node, index, parentNode) {
    if (parentNode.tagName === 'pre' || node.tagName === 'code') {
      // syntax highlight
      const lang = node.properties.className ? node.properties.className[0].split('-')[1] : 'md';
      let result = refractor.highlight(nodeToString(node), lang);

      node.children = result;
    }
  }
};
```

> Plugin inspired by [mdx-prism](https://github.com/j0lv3r4/mdx-prism).

The rehype plugin wraps the content of my code block in various `span` elements with different classes, such as `function`, `operator`, `keyword`, etc.

For example, this code block:

```html
<h1>Hello world</h1>
```

renders this html:

{<pre>
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;h1&lt;/span&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;Hello world&lt;span
class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;h1&lt;/span&gt;&lt;span
class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;

</pre>}

#### Usage

I added it to [mdx-bundler options](), and then it's just writing markdown as normal.

{

<pre>
  &#96;&#96;&#96;jsx <br />
  code goes here
  <br />
  &#96;&#96;&#96;
</pre>

}

I can tell it which language to use by adding it after the triple backticks, for example, if the code is in HTML, I'd do {<code>&#96;&#96;&#96;html</code>}.

### Adding the styles

I was then able to target these classes and style them. To do this in a maintanable way, I used [Stitches]().

With Stitches I am able to create a theme, and then use its tokens to later style the syntax highlight. But if you don't want to create your own theme, you can use [Prism themes](https://github.com/PrismJS/prism-themes).

```jsx
// stitches.config.ts
import { createCss } from '@stitches/react';

export const { styled } = createCss({
  theme: {
    fonts: {
      mono: 'Fira Mono, monospace',
    },
    fontSizes: {
      1: '12px',
      2: '14px',
    },
    colors: {
      black: 'rgba(19, 19, 21, 1)',
      white: 'rgba(255, 255, 255, 1)',
      gray: 'rgba(128, 128, 128, 1)',
      blue: 'rgba(3, 136, 252, 1)',
      red: 'rgba(249, 16, 74, 1)',
      yellow: 'rgba(255, 221, 0, 1)',
      pink: 'rgba(232, 141, 163, 1)',
      turq: 'rgba(0, 245, 196, 1)',
      orange: 'rgba(255, 135, 31, 1)',
    },
    space: {
      1: '4px',
      2: '8px',
      3: '16px',
    },
    radii: {
      1: '2px',
      2: '4px',
    },
  },
});
```

Now that Stitches is set up, I could import the `styled` function and use it to style the `pre` element.

```jsx
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  $$background: 'hsla(206 12% 89.5% / 5%)',
  $$text: '$colors$white',
  $$syntax1: '$colors$orange',
  $$syntax2: '$colors$turq',
  $$syntax3: '$colors$pink',
  $$syntax4: '$colors$pink',
  $$comment: '$colors$gray',
  $$removed: '$colors$red',
  $$added: '$colors$turq',

  boxSizing: 'border-box',
  padding: '$3',
  overflow: 'auto',
  fontFamily: '$mono',
  fontSize: '$2',
  lineHeight: '$3',
  whiteSpace: 'pre',
  backgroundColor: '$$background',
  color: '$$text',

  '& > code': { display: 'block' },

  '.token.parameter': {
    color: '$$text',
  },

  '.token.tag, .token.class-name, .token.selector, .token.selector .class, .token.function': {
    color: '$$syntax1',
  },

  '.token.attr-value, .token.class, .token.string, .token.number, .token.unit, .token.color': {
    color: '$$syntax2',
  },

  '.token.attr-name, .token.keyword, .token.rule, .token.operator, .token.pseudo-class, .token.important': {
    color: '$$syntax3',
  },

  '.token.punctuation, .token.module, .token.property': {
    color: '$$syntax4',
  },

  '.token.comment': {
    color: '$$comment',
  },

  '.token.atapply .token:not(.rule):not(.important)': {
    color: 'inherit',
  },

  '.language-shell .token:not(.comment)': {
    color: 'inherit',
  },

  '.language-css .token.function': {
    color: 'inherit',
  },

  '.token.deleted:not(.prefix), .token.inserted:not(.prefix)': {
    display: 'block',
    px: '$4',
    mx: '-$4',
  },

  '.token.deleted:not(.prefix)': {
    color: '$$removed',
  },

  '.token.inserted:not(.prefix)': {
    color: '$$added',
  },

  '.token.deleted.prefix, .token.inserted.prefix': {
    userSelect: 'none',
  },
});
```

Let me go through it step-by-step.

#### 1. Creating a component

I'm importing the `styled` function from `stitches.config.ts`. That's where we did the set up, to provide Stitches with our theme. Then I use the `styled` function to create a Stitches component.

```jsx
import { styled } from './stitches.config';

export const Pre = styled('pre', {...});
```

#### 2. Creating locally scoped tokens

I took advantage of Stitches' [locally-scoped tokens]() to define some variables that I'll then use to highlight the syntax.

This came in super handy when creating additional themes. Keep reading...

```jsx line=4-12
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  $$background: 'hsla(206 12% 89.5% / 5%)',
  $$text: '$colors$white',
  $$syntax1: '$colors$orange',
  $$syntax2: '$colors$turq',
  $$syntax3: '$colors$pink',
  $$syntax4: '$colors$pink',
  $$comment: '$colors$gray',
  $$removed: '$colors$red',
  $$added: '$colors$turq',

  // styles
});
```

#### 3. Adding base styles

Then I added the base styles for the `pre` and `code` elements.

```jsx line=6-16
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  // locally-scoped tokens

  boxSizing: 'border-box',
  padding: '$3',
  overflow: 'auto',
  fontFamily: '$mono',
  fontSize: '$2',
  lineHeight: '$3',
  whiteSpace: 'pre',
  backgroundColor: '$$background',
  color: '$$text',

  '& > code': { display: 'block' },

  // styles
});
```

#### 4. Adding syntax styles

I could target the classes generated by the rehype plugin and add syntax highlighting. With Stitches, I was able to reference the locally-scoped tokens, by using `$$` (two dollar signs).

```jsx line=6-58
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  // locally-scoped tokens and base styles

  '.token.parameter': {
    color: '$$text',
  },

  '.token.tag, .token.class-name, .token.selector, .token.selector .class, .token.function': {
    color: '$$syntax1',
  },

  '.token.attr-value, .token.class, .token.string, .token.number, .token.unit, .token.color': {
    color: '$$syntax2',
  },

  '.token.attr-name, .token.keyword, .token.rule, .token.operator, .token.pseudo-class, .token.important': {
    color: '$$syntax3',
  },

  '.token.punctuation, .token.module, .token.property': {
    color: '$$syntax4',
  },

  '.token.comment': {
    color: '$$comment',
  },

  '.token.atapply .token:not(.rule):not(.important)': {
    color: 'inherit',
  },

  '.language-shell .token:not(.comment)': {
    color: 'inherit',
  },

  '.language-css .token.function': {
    color: 'inherit',
  },

  '.token.deleted:not(.prefix), .token.inserted:not(.prefix)': {
    display: 'block',
    px: '$4',
    mx: '-$4',
  },

  '.token.deleted:not(.prefix)': {
    color: '$$removed',
  },

  '.token.inserted:not(.prefix)': {
    color: '$$added',
  },

  '.token.deleted.prefix, .token.inserted.prefix': {
    userSelect: 'none',
  },
});
```

#### Usage

I used XDM's [component substitution](https://github.com/kentcdodds/mdx-bundler#component-substitution) to replace the `pre` from the mdx files with the `Pre` Stitches component

```jsx
const components = {
  pre: ({ children }) => {
    return <Pre>{children}</Pre>;
  },
  code: ({ children, id }) => {
    return <code children={children} id={id} />;
  },
};
```

### Applying multiple themes

I relied on the Stitches Variant API to create multiple variations of the `Pre` component.

Creating multiple themes was as simple as overriding the previously created locally-scoped tokens. Love it!

```jsx line=6-30
import { styled } from './stitches.config';

export const Pre = styled('pre', {
  // locally-scoped tokens and base styles

  variants: {
    theme: {
      orange: {
        $$background: 'rgb(255 135 31 / 10%)',
        $$syntax1: '$colors$pink',
        $$syntax2: '$colors$turq',
        $$syntax3: '$colors$orange',
        $$syntax4: '$colors$orange',
      },
      pink: {
        $$background: 'hsl(345deg 66% 73% / 20%)',
        $$syntax1: '$colors$orange',
        $$syntax2: '$colors$turq',
        $$syntax3: '$colors$pink',
        $$syntax4: '$colors$pink',
      },
      turq: {
        $$background: 'rgba(0, 245, 196, 0.15)',
        $$syntax1: '$colors$orange',
        $$syntax2: '$colors$pink',
        $$syntax3: '$colors$turq',
        $$syntax4: '$colors$turq',
      },
    },
  },
});
```

### Highlight specific lines

I created another rehype utility to add line highlighting support.

```js
// rehype-highlght-line.js
const hastToHtml = require('hast-util-to-html');
const unified = require('unified');
const parse = require('rehype-parse');

const lineNumberify = function lineNumberify(ast, lineNum = 1) {
  let lineNumber = lineNum;
  return ast.reduce(
    (result, node) => {
      if (node.type === 'text') {
        if (node.value.indexOf('\n') === -1) {
          node.lineNumber = lineNumber;
          result.nodes.push(node);
          return result;
        }

        const lines = node.value.split('\n');
        for (let i = 0; i < lines.length; i++) {
          if (i !== 0) ++lineNumber;
          if (i === lines.length - 1 && lines[i].length === 0) continue;
          result.nodes.push({
            type: 'text',
            value: i === lines.length - 1 ? lines[i] : `${lines[i]}\n`,
            lineNumber: lineNumber,
          });
        }

        result.lineNumber = lineNumber;
        return result;
      }

      if (node.children) {
        node.lineNumber = lineNumber;
        const processed = lineNumberify(node.children, lineNumber);
        node.children = processed.nodes;
        result.lineNumber = processed.lineNumber;
        result.nodes.push(node);
        return result;
      }

      result.nodes.push(node);
      return result;
    },
    { nodes: [], lineNumber: lineNumber }
  );
};

const wrapLines = function wrapLines(ast, linesToHighlight) {
  const highlightAll = linesToHighlight.length === 1 && linesToHighlight[0] === 0;
  const allLines = Array.from(new Set(ast.map((x) => x.lineNumber)));
  let i = 0;
  const wrapped = allLines.reduce((nodes, marker) => {
    const line = marker;
    const children = [];
    for (; i < ast.length; i++) {
      if (ast[i].lineNumber < line) {
        nodes.push(ast[i]);
        continue;
      }

      if (ast[i].lineNumber === line) {
        children.push(ast[i]);
        continue;
      }

      if (ast[i].lineNumber > line) {
        break;
      }
    }

    nodes.push({
      type: 'element',
      tagName: 'div',
      properties: {
        dataLine: line,
        className: 'highlight-line',
        dataHighlighted: linesToHighlight.includes(line) || highlightAll ? 'true' : 'false',
      },
      children: children,
      lineNumber: line,
    });

    return nodes;
  }, []);

  return wrapped;
};

// https://github.com/gatsbyjs/gatsby/pull/26161/files
const MULTILINE_TOKEN_SPAN = /<span class="token ([^"]+)">[^<]*\n[^<]*<\/span>/g;

const applyMultilineFix = function (ast) {
  // AST to HTML
  let html = hastToHtml(ast);

  // Fix JSX issue
  html = html.replace(MULTILINE_TOKEN_SPAN, (match, token) =>
    match.replace(/\n/g, `</span>\n<span class="token ${token}">`)
  );

  // HTML to AST
  const hast = unified().use(parse, { emitParseErrors: true, fragment: true }).parse(html);

  return hast.children;
};

module.exports = function (ast, lines) {
  const formattedAst = applyMultilineFix(ast);
  const numbered = lineNumberify(formattedAst).nodes;

  return wrapLines(numbered, lines);
};
```

> Inspired by https://github.com/j0lv3r4/mdx-prism

Then, I imported this utility into the `rehype-highlight-code` plugin.

```js line=6,19-21
// rehype-highlight-code.js
const rangeParser = require('parse-numeric-range');
const visit = require('unist-util-visit');
const nodeToString = require('hast-util-to-string');
const refractor = require('refractor');
const highlightLine = require('./rehype-highlight-line');

module.exports = (options = {}) => {
  return (tree) => {
    visit(tree, 'element', visitor);
  };

  function visitor(node, index, parentNode) {
    if (parentNode.tagName === 'pre' && node.tagName === 'code') {
      // syntax highlight
      const lang = node.properties.className ? node.properties.className[0].split('-')[1] : 'md';
      let result = refractor.highlight(nodeToString(node), lang);

      // line highlight
      const linesToHighlight = rangeParser(node.properties.line || '0');
      result = highlightLine(result, linesToHighlight);

      node.children = result;
    }
  }
};
```

### Highlight specific words

I created another rehype utility to add word highlighting support.

```js
// rehype-word-highlight.js
const visit = require('unist-util-visit');
const hastToHtml = require('hast-util-to-html');
const unified = require('unified');
const parse = require('rehype-parse');

const CALLOUT = /__(.*?)__/g;

module.exports = (code) => {
  const html = hastToHtml(code);
  const result = html.replace(CALLOUT, (_, text) => `<span class="highlight-word">${text}</span>`);
  const hast = unified().use(parse, { emitParseErrors: true, fragment: true }).parse(result);
  return hast.children;
};
```
