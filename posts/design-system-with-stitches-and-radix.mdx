---
title: 'Design System with Stitches and Radix'
publishedAt: '2021-04-27'
---

I've built design systems with CSS, Sass, Stylus, css-modules, styled-components, emotion, system-components and styled-system. I've used BEM, scoped CSS, atomic CSS, and even made up conventions.

But they never felt _quite right_—some were too laborious and too error-prone. Others were too slow and too opinionated.

I've lost count of how many times I've been asked to build complex components from scratch—dialogs, tooltips, dropdown menus, popovers, sheets, tabs.

But they were all flawed and lacked fundamental accessibility features. When working against a deadline, it's almost impossible to build them correctly.

So for the last couple of years, we at [Modulz]() worked hard to facilitate how teams can build, maintain and scale their design systems—all whilst adhering to the WAI-ARIA design pattern.

---

If you've never heard of Stitches or Radix Primitives before, here's a little background.

### Stitches

Stitches is a styling solution focusing on component architecture and developer experience.

It introduces a first-class variant API, enabling design system authors to express their intent better. It's fully typed, catching potential mistakes and improving the scalability of design systems. It's lightweight, coming in at less than 5kb. And finally, it's a breeze to get up and running with it.

### Radix Primitives

Radix Primitives is a low-level UI component library focusing on accessibility, customisation and developer experience.

All its components adhere to the WAI-ARIA design patterns. They can be the base layer of your design system or adopted incrementally.

---

With the combination of Stitches and Radix Primitives, you can build a robust design system with little effort.

Ready? Let's get it.

- Set up Stitches
- Define your default theme
- Create a `Box` primitive
- Create your first component
- Add variants
- Use your component
- Add overrides
- Define your media queries
- Apply responsive styles
- Set up Radix
- Create a `Dialog` component
- Conclusion

## Set up Stitches

Install Stitches with `npm` or `yarn`.

```bash
yarn add @stitches/react
```

Create a `stitches.config.ts` (or `.js`) file and import the `createCss` function.

```jsx
// stitches.config.ts
import { createCss } from '@stitches/react';
```

Destructure and export the `styled` function.

```jsx line=4
// stitches.config.ts
import { createCss } from '@stitches/react';

export const { styled } = createCss();
```

The `createCss` function accepts a config. It's useful for defining a prefix, the default theme, media queries, custom utils, and other things. You can learn more about it [here]().

## Define your default theme

You can use the `theme` config key to define the default theme of your system. A theme consists of scales. Scales consist of tokens.

Tokens are essential for constraint-based design.

Here's a simplified theme, for the sake of brevity. For more complete themes, checkout the Modulz [design system config]().

```jsx
// stitches.config.ts
import { createCss } from '@stitches/react';

export const { styled } = createCss({
  theme: {
    colors: {
      black: 'rgba(19, 19, 21, 1)',
      white: 'rgba(255, 255, 255, 1)',
      gray: 'rgba(128, 128, 128, 1)',
      blue: 'rgba(3, 136, 252, 1)',
      red: 'rgba(249, 16, 74, 1)',
      yellow: 'rgba(255, 221, 0, 1)',
      pink: 'rgba(232, 141, 163, 1)',
      turq: 'rgba(0, 245, 196, 1)',
      orange: 'rgba(255, 135, 31, 1)',
    },
    fonts: {
      sans: 'Inter, sans-serif',
    },
    fontSizes: {
      1: '12px',
      2: '14px',
      3: '16px',
      4: '20px',
      5: '24px',
      6: '32px',
    },
    space: {
      1: '4px',
      2: '8px',
      3: '16px',
      4: '32px',
      5: '64px',
      6: '128px',
    },
    sizes: {
      1: '4px',
      2: '8px',
      3: '16px',
      4: '32px',
      5: '64px',
      6: '128px',
    },
    radii: {
      1: '2px',
      2: '4px',
      3: '8px',
      round: '9999px',
    },
    fontWeights: {},
    lineHeights: {},
    letterSpacings: {},
    borderWidths: {},
    borderStyles: {},
    shadows: {},
    zIndices: {},
    transitions: {},
  },
});
```

From this point on, tokens will be available when you write CSS. By default, Stitches maps CSS properties to theme scales. You can see the mapping [here](https://stitches.dev/docs/tokens#property-mapping).

## Create a `Box` primitive

One thing I like to do is create a low-level `Box` component.

Import the `styled` function to create your first component. Call the `styled` function providing the element you want to style and the optional style object. I don't usually add any styles for `Box`, so I left it out.

```jsx
// box.tsx
import { styled } from '@stitches/react';

export const Box = styled('div');
```

It's useful because components built with Stitches support a `css` prop, meaning you have access to tokens, utils, and media queries.

You can use the `Box` the lowest-level building block of your application.

{

<Preview>
  <Box>
    <Box
      css={{
        backgroundColor: '$turq',
        color: '$black',
        fontSize: '$5',
        padding: '$4',
      }}
    >
      Box
    </Box>
  </Box>
</Preview>
}

```jsx
import { Box } from './box';

const App = () => (
  <Box
    css={{
      backgroundColor: '$turq',
      color: '$black',
      fontSize: '$5',
      padding: '$4',
    }}
  >
    Box
  </Box>
);
```

It's worth noting that components built with Stitches are also polymorphic. So you can use the `as` prop to change the underlying element.

{

<Preview>
  <Box as="h1" css={{ color: '$turq' }}>
    Box as h1
  </Box>
</Preview>
}

```jsx
import { Box } from './box';

const App = () => (
  <Box as="h1" css={{ color: '$turq' }}>
    Box as h1
  </Box>
);
```

## Create components

You can use the `styled` function to create as many components as you need. Here's a demo button.

```jsx
// button.tsx
import { styled } from './stitches.config.ts';

export const Button = styled('button', {
  appearance: 'none',
  border: 'none',
  borderRadius: '99999px',
  lineHeight: 1,
  fontSize: '13px',
  height: '25px',
  paddingLeft: '10px',
  paddingRight: '10px',
  backgroundColor: 'gainsboro',

  '&:hover': {
    backgroundColor: 'lightgray',
  },
});
```

Because we've provided a theme, you can replace arbitrary values with tokens.

```jsx line=6-9,11
// button.tsx
import { styled } from './stitches.config.ts';

export const Button = styled('button', {
  // styles
  paddingLeft: '$2',
  paddingRight: '$2',
  backgroundColor: '$gray400',

  '&:hover': {
    backgroundColor: '$gray500',
  },
});
```

To use tokens, you need to prefix them with a `$` (dollar sign).

## Add variants

Stitches offer a first-class variant API. It's a powerful way to express alternative styles for a given component.

```jsx line=14-29
// button.tsx
import { styled } from './stitches.config.ts';

export const Button = styled('button', {
  appearance: 'none',
  border: 'none',
  borderRadius: '99999px',
  lineHeight: 1,
  fontSize: '13px',
  height: '25px',
  paddingLeft: '$2',
  paddingRight: '$2',

  variants: {
    color: {
      gray: {
        backgroundColor: '$gray400',
        '&:hover': {
          backgroundColor: '$gray500',
        },
      },
      purple: {
        backgroundColor: '$purple400',
        color: 'white',
        '&:hover': {
          backgroundColor: '$purple500',
        },
      },
    },
  },
});
```

We created a variant called `color` that can be either `gray` or `purple`. You can use the `defaultVariants` key to set it to `gray` by default:

```jsx line=14-16
// button.tsx
import { styled } from './stitches.config.ts';

export const Button = styled('button', {
  // styles

  variants: {
    color: {
      gray: {...},
      purple: {...},
    },
  },

  defaultVariants: {
    variant: 'gray',
  },
});
```

You can also add styles based on a combination of variants via the `compoundVariants` API. Learn more about [compound variants here]().

## Use your component

Now that you've created a component, you can use it the same way as any other React component.

{

<Preview>
  <DemoButton
    css={{
      backgroundColor: 'gainsboro',
      '&:hover': {
        backgroundColor: 'lightgray',
      },
    }}
  />
</Preview>
}

```jsx
import { Button } from './button';

function App() {
  return <Button>My button</Button>;
}
```

You can apply variants as defined in your component. The key becomes a prop.

{

<Preview>
  <DemoButton
    css={{
      backgroundColor: 'blueviolet',
      color: 'white',
      '&:hover': {
        backgroundColor: 'darkviolet',
      },
    }}
  />
</Preview>
}

```jsx line=4
import { Button } from './button';

function App() {
  return <Button color="purple">My button</Button>;
}
```

## Add overrides

Every component created with Stitches supports a `css` prop. This is useful for applying layout-related styles, overrides and exceptions.

{

<Preview>
  <DemoButton
    css={{
      width: '100%',
    }}
  />
</Preview>
}

```jsx line=4
import { Button } from './button';

function App() {
  return <Button css={{ width: '100%' }}>My button</Button>;
}
```

The `css` prop accepts a style object, much like the `styled` function. Unlike the `style` attribute, here, you can add pseudo-classes, descendant selectors, media queries, etc.

Additionally, you can access tokens via the `$` prefix in the `css` prop.

## Define your media queries

You can use the `media` config key to define the media queries of your system. This is useful for applying responsive styles and for responsively applying variants.

```jsx line=6-9
// stitches.config.ts
import { createCss } from '@stitches/react'

export { styled } = createCss({
  theme: {},
  media: {
    bp1: '(min-width: 575px)',
    bp2: '(min-width: 750px)',
  }
})
```

## Apply responsive styles

You can use your predefined media queries within the style object or when applying variants. To use media queries, prefix your media keys with an `@` (at sign).

For example, this is how you can increase the font size property over different media queries.

```jsx
// button.tsx
import { styled } from './stitches.config.ts';

const Button = styled('button', {
  // styles
  fontSize: '13px',

  '@bp1': {
    fontSize: '15px',
  },
  '@bp2': {
    fontSize: '19px',
  },
});
```

Alternatively, you can organise the increments as `variants`:

```jsx
// button.tsx
import { styled } from './stitches.config.ts';

const Button = styled('button', {
  // styles
  variants: {
    size: {
      small: { fontSize: '13px' },
      medium: { fontSize: '15px' },
      large: { fontSize: '19px' },
    },
  },

  defaultVariants: {
    size: 'small',
  },
});
```

And then _responsively apply them_:

```jsx line=5-8
import { Button } from './button';

function App() {
  return (
    <Button
      size={{
        '@bp1': 'medium',
        '@bp2': 'large',
      }}
    >
      My button
    </Button>
  );
}
```

With the features above, you have enough tools to build a component-driven, constraint-based design system.

## Set up Radix

Install Radix Primitives with `npm` or `yarn`. You need to install them individually.

```bash
yarn add @radix-ui/react-dialog
yarn add @radix-ui/react-dropdown-menu
yarn add @radix-ui/react-tooltip
```

## Create a dialog component

Most design systems will need a dialog component. Although they may seem like a straight forward component to build from scratch, there are many accessibility concerns to look out for.

For example, the focus should be automatically trapped within the dialog's content. The first interactive element should be focused by default. If there are no interactive elements, then the dialog's content should receive focus. When the dialog is closed, the focus must return to the dialog's trigger.

Pressing `Space/Enter` while the dialog trigger's focused should open the dialog. Pressing `Escape` should close the dialog.

The Radix dialog consists of the following parts:

```tsx
import * as Dialog from '@radix-ui/react-dialog';

export default () => (
  <Dialog.Root>
    <Dialog.Trigger />
    <Dialog.Overlay />
    <Dialog.Content>
      <Dialog.Close />
    </Dialog.Content>
  </Dialog.Root>
);
```

I can style the parts above and re-export them as part of my design system. I have full control over the API and abstractions.

This is what I want the API of my design system's dialog to look like:

```tsx
import { Dialog } from './dialog';
import { Button } from './button';

function App() {
  return (
    <Dialog>
      <DialogTrigger as={Button}>Open</DialogTrigger>
      <DialogContent>Dialog content goes here</DialogContent>
    </Dialog>
  );
}
```

Radix components are polymorphic, so they support the `as` prop. We can take advantage of this technique for the dialog trigger. Say we have three different types of buttons in our design system, and any of them can be used as the trigger. We don't want to add styles directly to the `Dialog.Trigger`, because that would mean duplicating the styles of our buttons — we lose the single source of truth. All we want is the trigger's functionality.

Also notice how in my API, I don't want to have to manually render the `Dialog.Overlay` part. I am making a decision that I always want the overlay to appear.

### Implementation

To achieve my desired API, I'll start by importing all of the dialog parts. Some parts will be a simple re-export, and some will be styled.

```jsx
import { styled } from '../stitches.config';
import { Cross1Icon } from '@radix-ui/react-icons';
import * as DialogPrimitive from '@radix-ui/react-dialog';

const StyledOverlay = styled(DialogPrimitive.Overlay, {
  backgroundColor: 'rgba(0, 0, 0, .15)',
  position: 'fixed',
  inset: 0,
});

export function Dialog({ children, ...props }) {
  return (
    <DialogPrimitive.Root {...props}>
      <StyledOverlay />
      {children}
    </DialogPrimitive.Root>
  );
}

const StyledContent = styled(DialogPrimitive.Content, {
  position: 'fixed',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  // other styles

  '&:focus': {
    outline: 'none',
  },
});

const StyledCloseButton = styled(DialogPrimitive.Close, {
  position: 'absolute',
  top: '$2',
  right: '$2',
});

export const DialogContent = React.forwardRef(({ children, ...props }, forwardedRef) => (
  <StyledContent {...props} ref={forwardedRef}>
    {children}
    <StyledCloseButton as={StyledCloseButton}>
      <Cross1Icon />
    </StyledCloseButton>
  </StyledContent>
));

export const DialogTrigger = DialogPrimitive.Trigger;
export const DialogClose = StyledCloseButton;
```

This process is similar to most Radix primitives. They're low-level enough to allow you to re-export them with your own API, yet high level enough that's an intuitive experience. It's all just components.

Currently, there are over 25 primitives available, with more coming almost every couple of weeks.

Learn more on [radix-ui.com]()

---

## Conclusion

With Stitches, you're able to create a resilient, maintainable and scalable design systems. You can focus on what matters the most. The system itself — your theme, scales and tokens. The look and feel of the components and their potential variations. The way each component can look at different breakpoints.

With Radix, you're able to delegate the logic and accessibility concerns of complex components while having full control over their aesthetics and behaviour. Style its parts and states. Use them controlled or uncontrolled. Add animations, either with CSS or an animation library.

It's an exciting time to be building UIs and design systems.

If you're interested in learning more, here are some useful resources:

- Modulz Discord for Stitches and Radix
- Stitches GitHub
- Stitches Twitter
- Radix GitHub
- Radix Twitter

Thanks for reading ✌️
